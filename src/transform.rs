use swc_common::{
    GLOBALS, Globals, Mark, SourceMap, comments::SingleThreadedComments, errors::Handler, sync::Lrc,
};
use swc_ecma_ast::Pass;
use swc_ecma_ast::{
    AssignExpr, AssignOp, EsVersion, Expr, ExprStmt, Ident, MemberExpr, MemberProp,
    ModuleExportName, ModuleItem, Program, Stmt,
};
use swc_ecma_codegen::{Emitter, text_writer::JsWriter};
use swc_ecma_parser::{Parser, StringInput, Syntax, TsSyntax, lexer::Lexer};
use swc_ecma_transforms_base::{fixer::fixer, hygiene::hygiene, resolver};
use swc_ecma_transforms_typescript::strip;
use swc_ecma_visit::{VisitMut, VisitMutWith};

use crate::store::CodeType;

/// Transforms ES module exports to globalThis.default assignments
struct ExportDefaultTransform;

impl VisitMut for ExportDefaultTransform {
    fn visit_mut_module_items(&mut self, items: &mut Vec<ModuleItem>) {
        let mut new_items = Vec::with_capacity(items.len());

        for item in items.drain(..) {
            match item {
                // export default { ... } or export default someExpr
                ModuleItem::ModuleDecl(swc_ecma_ast::ModuleDecl::ExportDefaultExpr(export)) => {
                    let assign = create_globalthis_default_assign(*export.expr);
                    new_items.push(ModuleItem::Stmt(Stmt::Expr(ExprStmt {
                        span: export.span,
                        expr: Box::new(assign),
                    })));
                }

                // export default function foo() {} or export default class Foo {}
                ModuleItem::ModuleDecl(swc_ecma_ast::ModuleDecl::ExportDefaultDecl(export)) => {
                    let span = export.span;

                    match export.decl {
                        swc_ecma_ast::DefaultDecl::Fn(fn_expr) => {
                            let func_expr = Expr::Fn(fn_expr);
                            let assign = create_globalthis_default_assign(func_expr);
                            new_items.push(ModuleItem::Stmt(Stmt::Expr(ExprStmt {
                                span,
                                expr: Box::new(assign),
                            })));
                        }

                        swc_ecma_ast::DefaultDecl::Class(class_expr) => {
                            let class_expr = Expr::Class(class_expr);
                            let assign = create_globalthis_default_assign(class_expr);
                            new_items.push(ModuleItem::Stmt(Stmt::Expr(ExprStmt {
                                span,
                                expr: Box::new(assign),
                            })));
                        }

                        _ => {
                            new_items.push(ModuleItem::ModuleDecl(
                                swc_ecma_ast::ModuleDecl::ExportDefaultDecl(export),
                            ));
                        }
                    }
                }

                // export { x as default } - generated by bundlers like esbuild
                ModuleItem::ModuleDecl(swc_ecma_ast::ModuleDecl::ExportNamed(mut export)) => {
                    if export.src.is_none() {
                        let mut default_specifier = None;
                        let mut other_specifiers = Vec::new();

                        for spec in export.specifiers.drain(..) {
                            if let swc_ecma_ast::ExportSpecifier::Named(named) = &spec {
                                let is_default_export = match &named.exported {
                                    Some(ModuleExportName::Ident(ident)) => {
                                        &*ident.sym == "default"
                                    }
                                    Some(ModuleExportName::Str(s)) => &*s.value == "default",
                                    None => false,
                                };

                                if is_default_export {
                                    let local_name = match &named.orig {
                                        ModuleExportName::Ident(ident) => ident.sym.to_string(),
                                        ModuleExportName::Str(s) => {
                                            s.value.to_string_lossy().into_owned()
                                        }
                                    };
                                    default_specifier = Some((export.span, local_name));
                                } else {
                                    other_specifiers.push(spec);
                                }
                            } else {
                                other_specifiers.push(spec);
                            }
                        }

                        if let Some((span, local_name)) = default_specifier {
                            let ident_expr = Expr::Ident(Ident::new_no_ctxt(
                                local_name.into(),
                                Default::default(),
                            ));
                            let assign = create_globalthis_default_assign(ident_expr);
                            new_items.push(ModuleItem::Stmt(Stmt::Expr(ExprStmt {
                                span,
                                expr: Box::new(assign),
                            })));
                        }

                        if !other_specifiers.is_empty() {
                            export.specifiers = other_specifiers;
                            new_items.push(ModuleItem::ModuleDecl(
                                swc_ecma_ast::ModuleDecl::ExportNamed(export),
                            ));
                        }
                    } else {
                        new_items.push(ModuleItem::ModuleDecl(
                            swc_ecma_ast::ModuleDecl::ExportNamed(export),
                        ));
                    }
                }

                other => new_items.push(other),
            }
        }

        *items = new_items;
    }
}

fn create_globalthis_default_assign(expr: Expr) -> Expr {
    Expr::Assign(AssignExpr {
        span: Default::default(),
        op: AssignOp::Assign,
        left: swc_ecma_ast::AssignTarget::Simple(swc_ecma_ast::SimpleAssignTarget::Member(
            MemberExpr {
                span: Default::default(),
                obj: Box::new(Expr::Ident(Ident::new_no_ctxt(
                    "globalThis".into(),
                    Default::default(),
                ))),
                prop: MemberProp::Ident(swc_ecma_ast::IdentName::new(
                    "default".into(),
                    Default::default(),
                )),
            },
        )),
        right: Box::new(expr),
    })
}

pub(crate) fn parse_worker_code(code: &[u8], code_type: &CodeType) -> Result<String, String> {
    let script =
        std::str::from_utf8(code).map_err(|e| format!("Invalid UTF-8 in worker code: {}", e))?;

    let cm: Lrc<SourceMap> = Default::default();
    let handler = Handler::with_emitter_writer(Box::new(std::io::stderr()), Some(cm.clone()));

    let (filename, syntax) = match code_type {
        CodeType::Javascript => ("script.js", Syntax::Es(Default::default())),
        CodeType::Typescript => (
            "script.ts",
            Syntax::Typescript(TsSyntax {
                tsx: false,
                ..Default::default()
            }),
        ),
        CodeType::Wasm | CodeType::Snapshot => {
            return Err("parse_worker_code called with non-JS code type".to_string());
        }
    };

    let fm = cm.new_source_file(
        Lrc::new(swc_common::FileName::Custom(filename.into())),
        script.to_string(),
    );

    let globals = Globals::default();
    GLOBALS.set(&globals, || {
        transform_code(cm, handler, fm, syntax, code_type)
    })
}

fn transform_code(
    cm: Lrc<SourceMap>,
    handler: Handler,
    fm: Lrc<swc_common::SourceFile>,
    syntax: Syntax,
    code_type: &CodeType,
) -> Result<String, String> {
    let comments = SingleThreadedComments::default();

    let lexer = Lexer::new(
        syntax,
        EsVersion::latest(),
        StringInput::from(&*fm),
        Some(&comments),
    );

    let mut parser = Parser::new_from(lexer);

    for e in parser.take_errors() {
        e.into_diagnostic(&handler).emit();
    }

    let module = parser.parse_module().map_err(|e| {
        let error_msg = format!("Parse error: {:?}", e);
        e.into_diagnostic(&handler).emit();
        error_msg
    })?;

    let unresolved_mark = Mark::new();
    let top_level_mark = Mark::new();

    // Wrap in Program to use with passes
    let mut program = Program::Module(module);

    // Apply resolver
    program.visit_mut_with(&mut resolver(unresolved_mark, top_level_mark, true));

    // Strip TypeScript (if TS)
    if matches!(code_type, CodeType::Typescript) {
        let mut ts_strip = strip(unresolved_mark, top_level_mark);
        ts_strip.process(&mut program);
    }

    // Extract module back
    let mut module = match program {
        Program::Module(m) => m,
        _ => unreachable!(),
    };

    // Transform exports to globalThis.default
    module.visit_mut_with(&mut ExportDefaultTransform);

    // Cleanup
    module.visit_mut_with(&mut hygiene());
    module.visit_mut_with(&mut fixer(Some(&comments)));

    // Generate code
    let mut buf = vec![];
    {
        let writer = JsWriter::new(cm.clone(), "\n", &mut buf, None);
        let mut emitter = Emitter {
            cfg: swc_ecma_codegen::Config::default(),
            cm: cm.clone(),
            comments: Some(&comments),
            wr: writer,
        };

        emitter
            .emit_module(&module)
            .map_err(|e| format!("JavaScript code generation error: {:?}", e))?;
    }

    String::from_utf8(buf).map_err(|e| format!("UTF-8 conversion error: {:?}", e))
}

#[cfg(test)]
mod tests {
    use super::*;

    fn transform(code: &str) -> String {
        parse_worker_code(code.as_bytes(), &CodeType::Javascript).expect("transform should succeed")
    }

    #[test]
    fn test_export_default_object() {
        let result = transform("export default { fetch() {} }");
        assert!(result.contains("globalThis.default"));
        assert!(!result.contains("export default"));
    }

    #[test]
    fn test_export_default_function() {
        let result = transform("export default function fetch() {}");
        assert!(result.contains("globalThis.default"));
        assert!(!result.contains("export default"));
    }

    #[test]
    fn test_export_as_default() {
        let result = transform(
            r#"
            const index_default = { fetch() {} };
            export { index_default as default };
            "#,
        );
        assert!(result.contains("globalThis.default = index_default"));
        assert!(!result.contains("export {"));
    }

    #[test]
    fn test_export_as_default_with_other_exports() {
        let result = transform(
            r#"
            const foo = 1;
            const bar = { fetch() {} };
            export { foo, bar as default };
            "#,
        );
        assert!(result.contains("globalThis.default = bar"));
    }

    #[test]
    fn test_no_export_no_transform() {
        let result = transform("const x = 1; console.log(x);");
        assert!(result.contains("const x = 1"));
        assert!(!result.contains("globalThis.default"));
    }

    #[test]
    fn test_addeventlistener_no_export() {
        let result = transform(
            r#"
            addEventListener('fetch', (event) => {
                event.respondWith(new Response('hello'));
            });
            "#,
        );
        assert!(!result.contains("globalThis.default"));
        assert!(result.contains("addEventListener"));
    }

    // =============================================================================
    // Edge cases - re-exports and complex patterns
    // =============================================================================

    #[test]
    fn test_reexport_default_from_module() {
        // export { x as default } from './other' - re-export pattern
        // In bundled code, this would already be resolved
        let result = transform(r#"export { foo as default } from './other';"#);
        println!("Re-export result: {}", result);
        // This keeps the export as-is since it has a `from` clause
        assert!(result.contains("export"));
    }

    #[test]
    fn test_export_all_from_module() {
        // export * from './module' - namespace re-export
        let result = transform(r#"export * from './module';"#);
        println!("Export all result: {}", result);
        // This is kept as-is - bundlers resolve this
        assert!(result.contains("export"));
    }

    #[test]
    fn test_export_default_class_extends() {
        // export default class extends Base {}
        let result = transform(
            r#"
            class Base {}
            export default class extends Base {
                fetch() { return new Response('hello'); }
            }
            "#,
        );
        println!("Class extends result: {}", result);
        assert!(result.contains("globalThis.default"));
        assert!(!result.contains("export default"));
    }

    #[test]
    fn test_export_default_arrow_iife() {
        // export default (() => ({ fetch: () => new Response('hi') }))()
        let result = transform(r#"export default (() => ({ fetch: () => new Response('hi') }))()"#);
        println!("Arrow IIFE result: {}", result);
        assert!(result.contains("globalThis.default"));
    }

    #[test]
    fn test_mixed_exports() {
        // Multiple export types in same file
        let result = transform(
            r#"
            export const VERSION = '1.0';
            export function helper() {}
            const worker = { fetch() { return new Response('ok'); } };
            export { worker as default };
            "#,
        );
        println!("Mixed exports result: {}", result);
        assert!(result.contains("globalThis.default = worker"));
        // Named exports are kept (we only transform default)
        assert!(result.contains("export"));
    }
}
